using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ProceduralPatrolController : MonoBehaviour
{
    public int numberOfPatrolPoints = 5; // Number of patrol points to generate
    public Vector3 patrolAreaSize = new Vector3(10f, 0f, 10f); // Size of the patrol area (X, Y, Z)
    public float patrolSpeed = 3f; // Speed of movement
    public float waitTimeAtPoint = 1f; // Time spent waiting at each point
    public float sightRange = 5f; // Range within which the fish can detect the player
    public float chaseSpeed = 5f; // Speed at which the fish chases the player
    public GameObject player; // Reference to the player object (drag and drop in Inspector)

    private List<Vector3> patrolPoints = new List<Vector3>(); // List of generated patrol points
    private int currentPatrolIndex = 0; // Current patrol point index
    private bool isPatrolling = true; // State to check if patrolling
    private bool isWaiting = false; // State to check if waiting
    private Vector3 patrolAreaCenter; // Center of the patrol area
    private bool isChasing = false; // State to check if chasing the player

    void Start()
    {
        patrolAreaCenter = transform.position; // Set the patrol center to the current position
        GeneratePatrolPoints();

        if (patrolPoints.Count == 0)
        {
            Debug.LogWarning("No patrol points generated by ProceduralPatrolController.");
            return;
        }

        // Move to the first patrol point
        transform.position = patrolPoints[currentPatrolIndex];

        if (player == null)
        {
            Debug.LogError("Player not assigned. Please drag and drop the player GameObject in the Inspector.");
        }
    }

    void Update()
    {
        if (player != null && Vector3.Distance(transform.position, player.transform.position) <= sightRange)
        {
            isChasing = true;
            ChasePlayer();
        }
        else
        {
            if (isChasing)
            {
                isChasing = false;
                ResumePatrolling();
            }

            if (isPatrolling && !isWaiting)
            {
                Patrol();
            }
        }
    }

    private void GeneratePatrolPoints()
    {
        patrolPoints.Clear();

        for (int i = 0; i < numberOfPatrolPoints; i++)
        {
            float randomX = Random.Range(-patrolAreaSize.x / 2, patrolAreaSize.x / 2);
            float randomZ = Random.Range(-patrolAreaSize.z / 2, patrolAreaSize.z / 2);
            float yPosition = patrolAreaCenter.y; // Maintain the Y level of the patrol area center

            Vector3 randomPoint = new Vector3(patrolAreaCenter.x + randomX, yPosition, patrolAreaCenter.z + randomZ);
            patrolPoints.Add(randomPoint);
        }
    }

    private void Patrol()
    {
        if (patrolPoints.Count == 0)
            return;

        Vector3 targetPoint = patrolPoints[currentPatrolIndex];

        // Move towards the current patrol point
        transform.position = Vector3.MoveTowards(transform.position, targetPoint, patrolSpeed * Time.deltaTime);

        // Check if the object has reached the patrol point
        if (Vector3.Distance(transform.position, targetPoint) < 0.1f)
        {
            StartCoroutine(WaitAtPoint());
        }
    }

    private IEnumerator WaitAtPoint()
    {
        isWaiting = true;

        // Wait for the specified time
        yield return new WaitForSeconds(waitTimeAtPoint);

        // Move to the next patrol point
        currentPatrolIndex = (currentPatrolIndex + 1) % patrolPoints.Count;
        isWaiting = false;
    }

    private void ChasePlayer()
    {
        // Move towards the player's position
        transform.position = Vector3.MoveTowards(transform.position, player.transform.position, chaseSpeed * Time.deltaTime);
    }

    // Stop the patrolling behavior
    public void StopPatrolling()
    {
        isPatrolling = false;
    }

    // Resume the patrolling behavior
    public void ResumePatrolling()
    {
        patrolAreaCenter = transform.position; // Update patrol center to the current position
        GeneratePatrolPoints(); // Regenerate patrol points around the new center
        isPatrolling = true;
    }

    // Visualize patrol points and sight range in the editor
    private void OnDrawGizmos()
    {
        Gizmos.color = Color.green;
        Gizmos.DrawWireCube(patrolAreaCenter, patrolAreaSize);

        if (patrolPoints != null && patrolPoints.Count > 0)
        {
            foreach (var point in patrolPoints)
            {
                Gizmos.color = Color.red;
                Gizmos.DrawSphere(point, 0.2f);
            }
        }

        // Draw sight range
        Gizmos.color = Color.blue;
        Gizmos.DrawWireSphere(transform.position, sightRange);
    }
}
